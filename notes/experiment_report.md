這份 `ripgrep` 的數據是完美的收官之作！結合之前 `Zed` 的失敗數據，你的專題現在擁有了一個**完整且誠實的科學論證**。

我們現在有三組關鍵數據：

1. **成功案例 (ripgrep Cold Start):** 證明在無路徑問題的小專案下，Reflink 能帶來 **1.46倍** 加速。
2. **邊界案例 (ripgrep Incremental):** 證明了 **2.5秒的固定開銷**，確認此技術不適合微量修改（慢 8 倍）。
3. **失敗案例 (Zed Cold Start):** 證明了 **路徑污染 (Path Pollution)** 是大型專案的致命傷，單靠檔案系統無法解決。
4. **空間紅利 (Disk Space):** 證明了 **77% 的空間節省**，這是任何專案都能享受到的絕對優勢。

我現在為你撰寫完整的 **(五) 實驗結果**、**(六) 分析與討論**、**(七) 結論** 以及 **(一) 摘要**。這將直接構成你期末報告的核心。

---

## (一) 摘要 (Abstract)

本研究旨在探討利用 Btrfs 檔案系統的寫入時複製 (CoW) 與 Reflink 機制，解決 Rust 語言在多分支開發時面臨的 `target` 目錄膨脹與切換分支需重新編譯之痛點。研究提出了一套名為「Cargo-CoW」的實驗性架構，透過 Git Worktree 與 `cp --reflink` 實現建置環境的秒級還原。

實驗結果顯示，在磁碟空間效率方面，本架構結合 Zstd 透明壓縮可節省高達 **77%** 的物理儲存空間，顯著降低了多分支開發的硬體成本。在建置效能方面，對於中小型專案 (`ripgrep`)，冷啟動建置速度提升了 **1.46 倍**；然而，研究亦發現了該技術的兩大限制：(1) 檔案系統操作存在約 **2.5 秒的固定開銷**，致使在微量修改的增量編譯場景下效能反而下降；(2) Rust 建置系統對「絕對路徑」的高度敏感性，導致在依賴複雜的大型專案 (`Zed Editor`) 中，跨目錄還原快取會因指紋 (Fingerprint) 不匹配而失效，觸發全量重編。

本研究結論指出，單純的檔案系統虛擬化不足以解決所有快取失效問題。未來的最佳實踐應是將 Reflink 機制與容器化技術 (如 Docker) 結合，透過固定掛載路徑來規避 Cargo 的路徑雜湊檢查，從而釋放 CoW 快取的全部潛力。

---

## (五) 實驗結果 (Experimental Results)

本章節展示 Cargo-CoW 架構在不同規模專案下的效能與空間表現。測試環境為 Arch Linux (Kernel 6.x)，檔案系統為 Btrfs (Mount options: `compress=zstd:3`)。

### 5.1 實驗對象與場景

* **小型專案 (Small Scale):** `ripgrep` (純 Rust CLI 工具)。
* **大型專案 (Large Scale):** `Zed Editor` (混合 Rust/C++、依賴複雜的 GUI 專案)。
* **測試場景:**
* **Scenario A (Cold Start):** 模擬 CI 環境或新分支建立，從零建置 vs Reflink 還原。
* **Scenario B (Incremental):** 模擬日常開發，修改單一檔案後重編。



### 5.2 建置時間效能分析

#### 表 1：冷啟動 (Cold Start) 效能比較

| 專案規模 | 傳統全量編譯 (Traditional) | Reflink 快照還原 | 加速倍率 | 結果判讀 |
| --- | --- | --- | --- | --- |
| **ripgrep** | 4.09 s | **2.80 s** | **1.46x** | **有效**。Reflink 省去了編譯依賴的時間。 |
| **Zed** | 140.8 s (Seed) | 146.1 s | **0.96x (無效)** | **失效**。因路徑改變導致 Cargo 指紋不匹配，觸發全量重編，且增加了複製開銷。 |

#### 表 2：增量編譯 (Incremental) 效能比較

| 專案規模 | 傳統增量編譯 (Traditional) | Reflink 增量編譯 | 效能落差 | 結果判讀 |
| --- | --- | --- | --- | --- |
| **ripgrep** | **0.67 s** | 5.37 s | **慢 8.0x** | 固定開銷 (Setup + Reflink) 遠大於 Rust 原生增量編譯時間。 |
| **Zed** | **4.85 s** | 144.0 s | **慢 29.7x** | 同上，且因快取失效導致重編，時間呈指數級暴增。 |

### 5.3 磁碟空間效率分析 (Disk Space Efficiency)

利用 `compsize` 工具分析 `ripgrep` 測試中，多個 Worktree 共存時的實際磁碟佔用。

* **邏輯大小 (Referenced):** 1.6 GB (若使用 Ext4 所需空間)
* **物理大小 (Disk Usage):** **372 MB**
* **空間節省率:** **77%**

數據證實，結合 Reflink 的區塊共享與 Zstd 壓縮，系統能以不到 1/4 的空間成本儲存 5 份完整的建置環境。

---

## (六) 分析與討論 (Analysis and Discussion)

### 6.1 固定開銷與適用邊界 (The Fixed Overhead)

實驗數據（特別是 `ripgrep` 的增量測試）揭示了 Reflink 架構存在一個約 **2.5 秒至 3.0 秒** 的「固定開銷」。

* **來源：** Git Worktree 的 Index 建立、`cp --reflink` 對數千個檔案的 Metadata 複製、以及 `mtime` 的修正操作。
* **意義：** 這定義了技術的「黃金交叉點」。僅當專案的 Clean Build 時間顯著大於 3 秒（例如 > 30秒）時，Reflink 的優勢才會浮現。對於日常的「存檔-編譯」循環（Inner Loop），Rust 原生的增量編譯（通常 < 1秒）仍是不可動搖的最佳解。

### 6.2 路徑污染：大型專案的阿基里斯腱

在 `Zed` 的實驗中，儘管使用了 `--remap-path-prefix` 參數嘗試消除絕對路徑，Reflink 方案仍未能阻止全量重編。經鑑識分析，主要原因有二：

1. 
**Cargo 的 Workspace Path Hashing:** Cargo 在計算指紋時，會將專案的絕對路徑納入考量。當 `target` 被移動到新的 Worktree 目錄時，Cargo 判定環境變更 。


2. 
**C/C++ 綁定的不可控性:** `Zed` 依賴的 C++ 函式庫（透過 `cc` crate 編譯）並未受 Rust 編譯參數控制，其 debug info 仍包含舊路徑，導致 Cargo 偵測到依賴污染 。



### 6.3 空間換取時間的策略價值

雖然在大型專案的「時間」加速上受挫，但「空間」上的紅利是無條件的。77% 的空間節省意味著開發者可以在本地保留數十個 Feature Branch 的建置狀態而無需擔心磁碟爆滿。這對於需要頻繁切換舊版本進行 Debug 的場景具有極高的實用價值。

---

## (七) 結論與未來研究方向 (Conclusion)

### 7.1 結論

本研究成功驗證了基於檔案系統 Reflink 的 Rust 建置快取方案的可行性與侷限性。

1. **空間效率卓越：** 透過 Btrfs CoW 機制，成功解決了 Rust `target` 目錄巨大的問題。
2. **小專案加速有效：** 在無複雜依賴的場景下，能有效縮短冷啟動時間。
3. **路徑敏感性限制：** Rust 工具鏈對絕對路徑的依賴，使得跨目錄的快取重用在複雜專案中極難實現，限制了此技術在大型單體專案 (Monorepo) 的應用。

### 7.2 未來研究方向：容器化封裝

針對「路徑污染」問題，未來的研究不應繼續在檔案系統層級尋求解法，而應引入 **Linux Namespaces** 技術。

* **方案：** 使用 Docker 或 Bubblewrap，將每一個 Git Worktree 掛載到容器內的**固定路徑** (例如 `/app`)。
* **預期效益：** 對 Cargo 而言，所有建置都發生在 `/app`，徹底騙過路徑指紋檢查，從而讓 Reflink 的物理加速效果能應用於 `Zed` 等巨型專案。

---
